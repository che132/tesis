[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Dissertation",
    "section": "",
    "text": "This is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "See Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "MAGIC.html",
    "href": "MAGIC.html",
    "title": "MAGIC",
    "section": "",
    "text": "Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "MAGIC.html#running-code",
    "href": "MAGIC.html#running-code",
    "title": "MAGIC",
    "section": "Running Code",
    "text": "Running Code\nWhen you click the Render button a document will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n1 + 1\n\n[1] 2\n\n\nYou can add options to executable code like this\n\n\n[1] 4\n\n\nThe echo: false option disables the printing of code (only output is displayed)."
  },
  {
    "objectID": "mosaic_metrics_pretty.html",
    "href": "mosaic_metrics_pretty.html",
    "title": "2  Estimate mosaic metrics MAGIC",
    "section": "",
    "text": "Is there any residual populations structure in the MAGIC population?\nCan we improve the parenta haplotype call in the MAGIC population if we increae the number of markers?\n\nHow does the choromosomic mosaic looks in the MAGIC population?\nWhat’s the median and maximum chromosomic chunk size in the MAGIC population?\nWhat’s the median and maximum “same genotype” chunk in a pairwise comparison of the MAGIC parents?\nWhat is the minimal number of markers that we need to obtain information similar to the total of 8.2 M markers?\n\n\nLogic: We hypothesize that most of the NAs or mistakes in the call of the parent in the MAGIC populations are because {qtl2} can’t tell apart one parent from the other with enough confidence (with \\(\\alpha = 0.5\\)) because the marker density is not enough to tell a parent from the other. In this case, increasing the number of markers between each chunk will help us only if the maximun size of the chunks with “same genotype” in the parents information is smaller than the recombination chunk size in the MAGIC population. IN other words, we’re adding more relevant information in each of these chunks that would allow us to differentiate one parent from the other.\nLoading libraries\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.1      ✔ purrr   1.0.1 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.3.0      ✔ stringr 1.5.0 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n\n\nWarning: package 'ggplot2' was built under R version 4.2.2\n\n\nWarning: package 'tidyr' was built under R version 4.2.2\n\n\nWarning: package 'readr' was built under R version 4.2.2\n\n\nWarning: package 'purrr' was built under R version 4.2.2\n\n\nWarning: package 'dplyr' was built under R version 4.2.2\n\n\nWarning: package 'stringr' was built under R version 4.2.2\n\n\nWarning: package 'forcats' was built under R version 4.2.2\n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\nlibrary(furrr)\n\nWarning: package 'furrr' was built under R version 4.2.2\n\n\nLoading required package: future\n\n\nWarning: package 'future' was built under R version 4.2.2\n\nplan(multisession)\nlibrary(arrow)\n\nWarning: package 'arrow' was built under R version 4.2.2\n\n\n\nAttaching package: 'arrow'\n\nThe following object is masked from 'package:utils':\n\n    timestamp\n\nlibrary(tidymodels)\n\n── Attaching packages ────────────────────────────────────── tidymodels 1.0.0 ──\n✔ broom        1.0.3          ✔ rsample      1.1.1     \n✔ dials        1.1.0          ✔ tune         1.0.1     \n✔ infer        1.0.4          ✔ workflows    1.1.2     \n✔ modeldata    1.1.0          ✔ workflowsets 1.0.0     \n✔ parsnip      1.0.3.9000     ✔ yardstick    1.1.0     \n✔ recipes      1.0.4          \n\n\nWarning: package 'broom' was built under R version 4.2.2\n\n\nWarning: package 'dials' was built under R version 4.2.2\n\n\nWarning: package 'infer' was built under R version 4.2.2\n\n\nWarning: package 'modeldata' was built under R version 4.2.2\n\n\nWarning: package 'recipes' was built under R version 4.2.2\n\n\nWarning: package 'rsample' was built under R version 4.2.2\n\n\nWarning: package 'tune' was built under R version 4.2.2\n\n\nWarning: package 'workflows' was built under R version 4.2.2\n\n\nWarning: package 'yardstick' was built under R version 4.2.2\n\n\n── Conflicts ───────────────────────────────────────── tidymodels_conflicts() ──\n✖ scales::discard() masks purrr::discard()\n✖ dplyr::filter()   masks stats::filter()\n✖ recipes::fixed()  masks stringr::fixed()\n✖ dplyr::lag()      masks stats::lag()\n✖ yardstick::spec() masks readr::spec()\n✖ recipes::step()   masks stats::step()\n• Use suppressPackageStartupMessages() to eliminate package startup messages\n\nlibrary(qtl2)\n\nWarning: package 'qtl2' was built under R version 4.2.2\n\n\n\nAttaching package: 'qtl2'\n\nThe following object is masked from 'package:readr':\n\n    read_csv\n\nlibrary(tidymodels)\nlibrary(finetune)\n\nWarning: package 'finetune' was built under R version 4.2.2\n\nlibrary(reshape2)\n\n\nAttaching package: 'reshape2'\n\nThe following object is masked from 'package:tidyr':\n\n    smiths\n\nlibrary(tidymodels)\n\nClean CrossObject: Remove weid markers and individuals based on their total number of recombinations and LODerror\n\nMEMA_DATA <- \n  read_cross2(\n    \"C:/Users/sergi/Documents/SAWERS LAB/MAGIC/genetic_mapping/MEMA_CTRL_wo_weird.yaml\"\n    )\n\nWarning in drop_incomplete_markers(output): Omitting 4738 markers that are not\nin both genotypes and maps\n\n\nWarning in check_cross2(output): Physical map out of order on chr 1, 2, 3, 4,\n5, 6, 7, 8, 9, 10\n\nsnp.info.founders <- readr::read_csv(\n  \"C:/Users/sergi/Documents/SAWERS LAB/MAGIC/genetic_mapping/snp.info.founders.csv\"\n  ) %>%\n  filter(!is.na(snp))\n\nRows: 19654 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): snp\ndbl (3): chr, pos, sdp\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n######################################################################################\n# Identify and remove weird markers and individuals based on error LOD and number of #   \n# recombinations                                                                     #\n######################################################################################\n\ngenmap_MEMA <- MEMA_DATA$gmap\n\n# Estimate genotype probabilities\nset.seed(100)\ngenoprob_MEMA <-\n  calc_genoprob(\n    cross = MEMA_DATA, \n    map = genmap_MEMA, \n    error_prob=0.002) %>%\n  clean_genoprob ()\n\n# Estimate the genotypes with maximum marginal probabilities\nset.seed(100)\ngeno_maxprob_MEMA <- \n  maxmarg(\n    probs = genoprob_MEMA,\n    minprob = 0.95\n    ) #assigns founder code to each marker/pos\n\n# Estimate the genotypes with maximum marginal probabilities with letters\nset.seed(100)\ngeno_maxprob_letters_MEMA <- maxmarg(\n  probs= genoprob_MEMA,\n  minprob = 0.95,\n  return_char = TRUE\n  )\n\nEstimate the error lod probability for any marker for any family. Positive LOD scores suggest that there might be a mistake in the genotype probability. I’m estimating the proportion of genotype calls in each marker whose errorLOD > 0 and estimate the top 5 percentile values of the proportion distribution and remove the markers whose proportion belong to this group.\n\n# Calculate genotyping error LOD scores\nset.seed(100)\nerrorlod_MEMA <- \n  calc_errorlod(\n    cross = MEMA_DATA, \n    probs = genoprob_MEMA\n    )\n\nerrorlod_MEMA <- do.call(\"cbind\", errorlod_MEMA)\n\n# matrix to df\nerrorlod_MEMA_df <- \n  errorlod_MEMA %>%\n  as_tibble(rownames = \"family\")\n\n# Estimate the proportion of LODerror > 0 in every marker\nerrorlod_MEMA_prop_marker <- \n  errorlod_MEMA_df %>%\n  pivot_longer(-family) %>%\n  filter(!is.infinite(value)) %>%\n  group_by(name) %>%\n  summarise(prop = sum(value >= 0)/dim(errorlod_MEMA_df)[1])\n\nerrorlod_MEMA_prop_marker\n\n# A tibble: 14,176 × 2\n   name         prop\n   <chr>       <dbl>\n 1 1_100088401 0.125\n 2 1_100224800 0.115\n 3 1_100225275 0.135\n 4 1_100229005 0.11 \n 5 1_100344399 0.13 \n 6 1_100344420 0.13 \n 7 1_100344944 0.145\n 8 1_100384962 0.13 \n 9 1_100385294 0.16 \n10 1_100388059 0.135\n# … with 14,166 more rows\n\n# Estimate the 95 percentile of the LODerror proportion distribution \nerrorlod_95_perc <- quantile(errorlod_MEMA_prop_marker$prop, 0.95)\n\nerrorlod_95_perc\n\n95% \n0.2 \n\n# Remove all the markers with prop >=0.2\n\nerrorlod_MEMA_prop_marker %>%\n  ggplot(data =., aes(x = prop)) +\n  geom_density(linewidth = 1) +\n  xlab(\"Proportion of LODerror > 0 per marker\")  +\n  geom_vline(\n    aes(xintercept = errorlod_95_perc), \n    color = \"red\", \n    linetype = \"dashed\", \n    linewidth = 1\n    ) +\n  theme(\n    panel.background = element_rect(fill = \"white\", colour = \"grey50\"),  \n    text = element_text(size = 12),\n    legend.position = \"top\"          \n    )\n\n\n\n# Select markers in the 95 percentile to remove\nerrorlod_marker_remove <- errorlod_MEMA_prop_marker %>%\n  filter(prop >= errorlod_95_perc) %>%\n  .$name\n\n#############################################\n# Count number of recombinations per family #\n#############################################\n\n# Estimate the total number of recombinations per family\nset.seed(100)\nn_recomb_family_MEMA <- \n  count_xo(geno = geno_maxprob_MEMA) %>%\n  as_tibble(rownames = \"family\") %>%\n  pivot_longer(-family) %>%\n  group_by(family) %>%\n  summarise(n_recomb = sum(value)) %>%\n  arrange(desc(n_recomb)) \n\n# Identify outliers in the distribution of genomewide recombination events\nn_recomb_family_MEMA %>%\n  ggplot(data =., aes(y = n_recomb)) +\n  geom_boxplot() +\n  theme(\n    panel.background = element_rect(fill = \"white\", colour = \"grey50\"),  \n    text = element_text(size = 12),\n    plot.title = element_text(hjust = 0.5)\n    ) +\n  ggtitle(\"Distribution of number of genome-wide number of recombinations per family\")\n\n\n\n# Outliers total number of recomb\noutliers_lots_recomb_MEMA <- \n  boxplot(n_recomb_family_MEMA$n_recomb, plot = F)$out\n\n# non outlier families\nfamily_normal_recomb <- \n  n_recomb_family_MEMA %>%\n  filter(! n_recomb %in% outliers_lots_recomb_MEMA) %>%\n  .$family \n\nMEMA_DATA_wo_weird <- \n  MEMA_DATA %>%\n  drop_markers(errorlod_marker_remove) %>%\n  subset(x =., ind = family_normal_recomb)\n\nIs there any population structure in the MEMA population?\nApproach: I’m going to estimate the kinship matrix using the overall option and a decomposition of eigenvalues of the same matrix and detect population structure.\n\n# Estimate genotype probabilities\nset.seed(100)\ngenoprob_wo_weird_MEMA <-\n  calc_genoprob(\n    cross = MEMA_DATA_wo_weird, \n    map = genmap_MEMA, \n    error_prob=0.002) %>%\n  clean_genoprob ()\n\n# Estimate Allele probabilities\nset.seed(100)\nallele_prob_MEMA <- \n  genoprob_to_alleleprob(genoprob_wo_weird_MEMA)\n\n# Estimate kinship matrix \nset.seed(100)\nkinship_wo_weird_MEMA <- calc_kinship(\n  probs = allele_prob_MEMA,\n  type = \"overall\"\n  )\n\n# Estimate the eigenvalue decomposition of the kinship matrix\nset.seed(100)\neigen_kinship_MEMA <- \n  decomp_kinship(kinship_wo_weird_MEMA)\n\n# correlation matrix of the kinship matrix\nset.seed(100)\ncorr_kindhip_MEMA <- \n  scale_kinship (kinship_wo_weird_MEMA)\n\n# Pairwise correlation of families\npairwise_geno_corr_MEMA <- corr_kindhip_MEMA %>%\n  as_tibble(rownames = \"family\") %>%\n  pivot_longer(-family) %>%\n  filter(family != name) %>%\n  mutate(code = map2_chr(\n    .x = family,\n    .y = name,\n    .f = ~ paste0(.x, .y) %>% str_split(\"\") %>% unlist() %>% sort() %>% paste(collapse = \"\")\n    )) %>%\n  group_by(code) %>%\n  filter(row_number() == 1) %>%\n  ungroup() %>%\n  select(-code) \n\n# Estimate 99 percentile of pairwise correlation\ngeno_corr_99_perc <- quantile(pairwise_geno_corr_MEMA$value, 0.99)\n\ngeno_corr_99_perc\n\n      99% \n0.2882856 \n\n# plot the distribution of the pairwise correlation between families \npairwise_geno_corr_MEMA %>%\n  ggplot(data =., aes(x = value)) +\n  geom_density(linewidth = 1) +\n  xlab(\"Pairwise kinship between families (vertical line = 99 percentile)\")  +\n  geom_vline(\n    aes(xintercept = geno_corr_99_perc), \n    color = \"red\", \n    linetype = \"dashed\", \n    linewidth = 1\n    ) +\n  theme(\n    panel.background = element_rect(fill = \"white\", colour = \"grey50\"),  \n    text = element_text(size = 12),\n    legend.position = \"top\"          \n    )\n\n\n\n# Identify family pairwise correlation values in the 99 percentile\nfamilyes_high_corr <- \n  pairwise_geno_corr_MEMA %>%\n  filter(value >= geno_corr_99_perc) %>%\n  arrange(desc(value))\n\nfamilyes_high_corr\n\n# A tibble: 27 × 3\n   family  name    value\n   <chr>   <chr>   <dbl>\n 1 MEMA210 MEMA211 0.736\n 2 MEMA245 MEMA244 0.714\n 3 MEMA162 MEMA163 0.695\n 4 MEMA128 MEMA127 0.675\n 5 MEMA307 MEMA308 0.638\n 6 MEMA033 MEMA034 0.631\n 7 MEMA133 MEMA132 0.612\n 8 MEMA055 MEMA054 0.563\n 9 MEMA252 MEMA253 0.517\n10 MEMA168 MEMA078 0.496\n# … with 17 more rows\n\n# Select families to drop that are in the 99th percentile but doesn't have a phenotype in the TC experiment\n\ngenotyped_fam_MEMA <- \n  MEMA_DATA_wo_weird$geno$`1` %>% rownames()\n\nfamilies_no_pheno <- \n  MEMA_DATA_wo_weird$pheno %>%\n  rownames() %>%\n  setdiff(genotyped_fam_MEMA, .)\n\nfamilies_no_pheno_high_corr <- \n  familyes_high_corr %>%\n  rowid_to_column() %>%\n  rename(cor = value) %>%\n  pivot_longer(c(family, name)) %>%\n  count(value) %>%\n  arrange(desc(n)) %>%\n  filter(value %in% families_no_pheno) %>%\n  .$value\n\n# Drop families with high correlation and not phenotyped: c(\"MEMA163\", \"MEMA210\", \"MEMA252\")\n\nMEMA_DATA_wo_weird2 <- MEMA_DATA_wo_weird %>%\n  subset(ind = setdiff(genotyped_fam_MEMA, families_no_pheno_high_corr))\n\nIn the absence of population structure we can expect a correlation between families of 1/8. Any significant deviation from this number would imply that there is residual population structure in the population. The distribution of the pairwise correlation values for the MEMA family is right skewed with a median value of ~ 0.14, close to 0.125 (1/8) expected. This value is inflated a little bit by weird families that have a lot of correlation. We hypothesize that the high correlation values for these families (for instance families MEMA210-MEMA211; cor = 0.736) was the result of either mistakes in the development of families: Someone mistakenly grabbed seed from an incorrect envelope that was planted and generated a very closely relted family, or it could also be the result of mistakes in collecting tissue from plants for genotyping. Nevertheless, the results show that the median pairwise correlation doesn’t deviate that much from the expected under the hypothesis of no population structure, so we can conclude that there is a reduced population structure in the MEMA pop. We’re going to remove highly correlated individuals for whom we don’t have phenotypic data.\n\n3 What is the size of the recombination chunks in the MEMA population?\n\n# Estimate genotype probabilities\nset.seed(100)\ngenoprob_wo_weird2_MEMA <-\n  calc_genoprob(\n    cross = MEMA_DATA_wo_weird2, \n    map = genmap_MEMA, \n    error_prob=0.002) %>%\n  clean_genoprob ()\n\n# Estimate Allele probabilities\nset.seed(100)\ngeno__wo_weird2_MEMA <- \n  maxmarg(\n    probs = genoprob_wo_weird2_MEMA,\n    minprob = 0.95\n    )\n\n# Guess the phase of each family in each chromosome\nphase_MEMA <- guess_phase(MEMA_DATA_wo_weird2, geno__wo_weird2_MEMA)\n\n# genetic map\ngenmap_MEMA <- \n  MEMA_DATA_wo_weird2$gmap %>%\n  map_df(.x = ., .f = ~ .x %>% enframe(name = \"marker\", value = \"g_pos\"))\n\n# markers at the end of each chromosome\ngenmap_chr_end <- \n  genmap_MEMA %>%\n  separate(marker, into = c(\"chr\", \"p_pos\"), sep = \"_\", remove = F) %>%\n  mutate(\n    chr = as.integer(chr),\n    p_pos = as.integer(p_pos)\n    ) %>%\n  arrange(chr, p_pos) %>%\n  group_by(chr) %>%\n  filter(row_number() == max(row_number())) %>%\n  mutate(p_pos = p_pos/1e6) %>%\n  ungroup() %>%\n  rename(chr_end = p_pos)\n  \n\n# Identify the recombination breakpoints in the MEMA population\nset.seed(100)\nrecomb_location_MEMA <- \n  locate_xo(phase_MEMA, map = MEMA_DATA_wo_weird2$gmap) %>%\n  map_df(\n    .x = .,\n    .f = ~ map_df(\n      .x = .,\n      .f = ~ enframe(.x, name = NULL, value = \"location\"),\n      .id = \"family\"\n      ),\n    .id = \"chr\"\n  ) %>%\n  mutate(marker = find_marker(MEMA_DATA$gmap, chr = chr, pos = location)) %>%\n  mutate(chr = as.integer(chr))\n\n# Estimate the size of the recombination chunks in the MEMA population\nrecomb_chunk_size_MEMA <- \n  recomb_location_MEMA  %>%\n  group_by(family, chr) %>%\n  nest() %>%\n  mutate(data = map(\n    .x = data, \n    .f = ~ .x %>% add_row(location = NA, marker = NA)\n    )) %>%\n  ungroup() %>%\n  unnest(c(data), keep_empty = T) %>%\n  group_by(family, chr) %>%\n  mutate(\n    pos = gsub(\"^\\\\d{1,2}_\", \"\", marker) %>% as.integer() %>% \"/\"(1e6),\n    chr = as.integer(chr)\n    ) %>%\n  mutate(\n    start = lag(pos, default = 0),\n    end = pos\n    ) %>%\n  left_join(genmap_chr_end %>% select(-marker), by = \"chr\") %>%\n  mutate(end = ifelse(is.na(pos), chr_end, end))  %>%\n  select(family, chr, location, marker, start, end) %>%\n  ungroup() %>%\n  mutate(chunk_size = end - start)  %>%\n  mutate(\n    p_pos_start = find_marker(MEMA_DATA$gmap, chr = chr, pos = start),\n    p_pos_end = find_marker(MEMA_DATA$gmap, chr = chr, pos = end)) %>%\n  mutate(\n    across(contains(\"p_pos\"), ~ gsub(\"\\\\d{1,2}_\", \"\", .) %>% as.integer() %>% \"/\"(1e6))\n  ) %>%\n  mutate(p_chunk_size = p_pos_end - p_pos_start) %>%\n  filter(chunk_size > 0 & p_chunk_size > 0)\n\nrecomb_chunk_size_MEMA\n\n# A tibble: 22,217 × 10\n   family    chr location marker     start   end chunk…¹ p_pos…² p_pos…³ p_chu…⁴\n   <chr>   <int>    <dbl> <chr>      <dbl> <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n 1 MEMA156     1     14.0 1_7987929   0     7.99   7.99     1.74    4.91   3.17 \n 2 MEMA156     1     34.1 1_18969916  7.99 19.0   11.0      4.91   11.3    6.40 \n 3 MEMA156     1     65.8 1_42129633 19.0  42.1   23.2     11.3    23.6   12.3  \n 4 MEMA156     1     97.8 1_71985242 42.1  72.0   29.9     23.6    50.5   26.9  \n 5 MEMA156     1     98.6 1_72903601 72.0  72.9    0.918   50.5    53.8    3.24 \n 6 MEMA156     1     99.4 1_74159005 72.9  74.2    1.26    53.8    54.8    1.01 \n 7 MEMA156     1    101.  1_78116605 74.2  78.1    3.96    54.8    57.4    2.69 \n 8 MEMA156     1    104.  1_80559358 78.1  80.6    2.44    57.4    58.3    0.826\n 9 MEMA156     1    105.  1_81673169 80.6  81.7    1.11    58.3    59.0    0.751\n10 MEMA156     1    105.  1_82472265 81.7  82.5    0.799   59.0    59.4    0.420\n# … with 22,207 more rows, and abbreviated variable names ¹​chunk_size,\n#   ²​p_pos_start, ³​p_pos_end, ⁴​p_chunk_size\n\nrecomb_med_max_size <- \n  recomb_chunk_size_MEMA %>%\n  summarise(\n    min_chunk_size = min(chunk_size),\n    median_chunk_size = median(chunk_size),\n    max_chunk_size = max(chunk_size)\n    )\n\nrecomb_med_max_size\n\n# A tibble: 1 × 3\n  min_chunk_size median_chunk_size max_chunk_size\n           <dbl>             <dbl>          <dbl>\n1         0.0180              6.43           249.\n\nrecomb_chunk_size_MEMA %>%\n  ggplot(data =., aes(x = chunk_size)) +\n  geom_density(linewidth = 1) +\n  xlab(\"Recombination chunk size (cM)\")  +\n  geom_vline(\n    data = recomb_med_max_size, \n    aes(xintercept = median_chunk_size),\n    color = \"red\",\n    linetype = \"dashed\",\n    linewidth = 1\n    ) +\n  theme(\n    panel.background = element_rect(fill = \"white\", colour = \"grey50\"),  \n    text = element_text(size = 12),\n    legend.position = \"top\"          \n    ) +\n  ggtitle(\"Distribution of the recombination chunk sizes in the MEMA population\")\n\n\n\nrecomb_med_max_p_size <- \n  recomb_chunk_size_MEMA %>%\n  summarise(\n    min_chunk_size_p = min(p_chunk_size),\n    median_chunk_size_p = median(p_chunk_size),\n    max_chunk_size_p = max(p_chunk_size)\n    )\n\nrecomb_med_max_p_size\n\n# A tibble: 1 × 3\n  min_chunk_size_p median_chunk_size_p max_chunk_size_p\n             <dbl>               <dbl>            <dbl>\n1       0.00000800                4.20             235.\n\nrecomb_chunk_size_MEMA %>%\n  ggplot(data =., aes(x = p_chunk_size)) +\n  geom_density(linewidth = 1) +\n  xlab(\"Recombination chunk size (cM)\")  +\n  geom_vline(\n    data = recomb_med_max_p_size,\n    aes(xintercept = median_chunk_size_p),\n    color = \"red\",\n    linetype = \"dashed\",\n    linewidth = 1\n    ) +\n  theme(\n    panel.background = element_rect(fill = \"white\", colour = \"grey50\"),  \n    text = element_text(size = 12),\n    legend.position = \"top\"          \n    ) +\n  ggtitle(\"Distribution of the recombination chunk sizes in the MEMA population\")\n\n\n\n\nThe median recombination chunk size is ~ 4.20 MB, but they can go from almos 0 to >200 MB. It is kinda weird. The most probable thing is that those very small chunks are just mistakes in the haplotype calling and therefore the chunks are very small. Is also worth to mention that the missing information in the parentall haplotype calls seems to be located when one haplotype ends to when the other starts, so it seems that with this marker density (~ 14K markers), rqtl2 can’t confidently assign a parental haplotype in these transition regions.\n\n\n4 What is the average size of the “same genotype” chunks in the parental magic haplotype?\nWe hypothesize that rqtl2 is having trouble in calling parental haplotypes with confidence because there are chromosomic chunks where two or more parents have the same genotype, and with the actual marker density rqtl2 cannot tell apart one from the other. So we want to assess if including a greater number of markers (that come from WGS) can reduce the size of this chunks, therefore becoming easier to identify one parent from the other. In the other hand, it might be the case that even with a greater marker density the chunks stay about the same size, so including a genotype strategy to increase the marker density in the MEMA families will not be helpfull at all.\n\n# Import CHIP data\n\nmema_par_hap_raw <- \n  read_delim(\n    \"C:/Users/sergi/Documents/SAWERS LAB/MAGIC/mosaic_estimates/gen_mosaic_estimates/magic_parents_HAPMAP.txt\",\n    delim = \"\\t\", \n    escape_double = FALSE, \n    trim_ws = TRUE\n    )\n\nRows: 23645 Columns: 19\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (11): rs#, alleles, strand, m_zc, m_nt, m_rv, m_gd, m_tb, m_mu, m_ja, m_pt\ndbl  (2): chrom, pos\nlgl  (6): assembly#, center, protLSID, assayLSID, panelLSID, QCcode\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ncolnames_WGS_data <- arrow::open_dataset(\n  sources = \"C:/Users/sergi/Documents/SAWERS LAB/MAGIC/mosaic_estimates/gen_mosaic_estimates/parents_WGS_hap.parquet\"\n  )$schema$names\n\nparent_chip_MEMA <-  c(\"GD\", \"JL\", \"MS\", \"NT\", \"PT\", \"RV\", \"TB\", \"ZC\")\n\n\nmema_par_hap <- \n  mema_par_hap_raw %>%\n  select(marker = `rs#`, chrom, pos, contains(\"m_\")) %>%\n  select(marker:pos, sort(names(.))) %>%\n  rename_with(.cols = contains(\"m_\"), ~ c(\"GD\", \"JL\", \"MS\", \"NT\", \"PT\", \"RV\", \"TB\", \"ZC\")) %>%\n  pivot_longer(-c(marker:pos), names_to = \"parental\", values_to = \"geno\")\n\nchip_parent_comp_mema <- \n  crossing(p1 = parent_chip_MEMA, p2 = parent_chip_MEMA) %>%\n  filter(p1 != p2) %>%\n  mutate(code = map2_chr(\n    .x = p1,\n    .y = p2,\n    .f = ~ paste0(.x, .y) %>% str_split(\"\") %>% unlist() %>% sort() %>% paste(collapse = \"\")\n    )) %>%\n  group_by(code) %>%\n  filter(row_number() == 1) %>%\n  ungroup() %>%\n  select(-code) %>%\n  left_join(mema_par_hap %>% rename(geno1 = geno), by = c(\"p1\" = \"parental\")) %>%\n  left_join(mema_par_hap %>% rename(geno2 = geno), by = c(\"p2\" = \"parental\", \"marker\", \"chrom\", \"pos\")) \n\nchip_parent_chunk_info <- \n  chip_parent_comp_mema %>%\n  mutate(comp_group = paste(p1, p2, sep =\"-\")) %>%\n  select(-c(p1, p2)) %>%\n  group_by(comp_group) %>%\n  nest() %>%\n  mutate(chunk_info = future_map(\n    .x = data,\n    .f = ~ .x %>%\n      group_by(chrom) %>%\n      rowid_to_column() %>%\n      filter(geno1 == geno2) %>%\n      mutate(\n        dif_inicio = lead(rowid) - rowid,\n        dif_final =  lag(dif_inicio)\n        ) %>%\n      filter(dif_inicio == 1 | dif_final == 1) %>%\n      mutate(block = ifelse(dif_inicio == 1, NA, rowid)) %>%\n      fill(block, .direction = \"up\") %>%\n      group_by(block) %>%\n      mutate(chunck_n_marker = n()) %>%\n      filter(rowid == min(rowid) | rowid == max(rowid)) %>%\n      group_by(chrom, block) %>%\n      summarise(\n        chunck_n_marker = first(chunck_n_marker),\n        chunk_size = diff(pos),\n        chunck_name = paste(first(rowid), last(rowid), sep = \"-\"),\n        spans = paste(round(first(pos)/1e6, 2), round(last(pos)/1e6, 2), sep =\"-\")\n        ) %>%\n      ungroup()\n  ))\n\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'chrom', 'block'. You can override using\nthe `.groups` argument.\n\nchip_parent_chunk_info_pre <- \n  chip_parent_chunk_info  %>%\n  select(comp_group, chunk_info) %>%\n  ungroup() %>%\n  unnest(chunk_info) %>%\n  mutate(chunk_size = round(chunk_size/1e6, 2)) %>%\n  filter(chunk_size != 0)\n\nchip_parent_chunk_info_pre %>%\n  group_by(comp_group) %>%\n  summarise(\n    med_size = median(chunk_size),\n    max_size = max(chunk_size)\n    ) %>%\n  summarise(\n    med_size = median(med_size),\n    max_size = median(max_size)\n  )\n\n# A tibble: 1 × 2\n  med_size max_size\n     <dbl>    <dbl>\n1     0.19     12.1\n\nchip_parent_chunk_mema_label <- chip_parent_chunk_info_pre %>%\n  group_by(comp_group) %>%\n  summarise(\n    label = sapply(c(\"min\", \"max\", \"median\"), do.call, list(x = chunk_size))  %>%\n      round(., 2) %>%\n      paste(names(.), ., sep = \" = \") %>%\n      paste(., collapse = \"\\n\"),\n    y = 1000,\n    chunk_size = 10\n  )\n\nchip_parent_chunk_info_pre %>%\n  ggplot(data =., aes(x = chunk_size, fill = comp_group )) +\n  geom_histogram(color = \"black\", linewidth = 0.75, bins = 30) +\n  geom_vline(\n    data = . %>% group_by(comp_group ) %>% summarise(chunk_size = median(chunk_size)),\n    aes(xintercept = chunk_size),\n    linetype = \"dashed\",\n    linewidth = 0.75\n  ) +\n  geom_text(\n    data = chip_parent_chunk_mema_label,\n    aes(label = label, x = chunk_size, y = y, hjust = \"bottom\"),\n  ) +\n  facet_wrap(. ~ comp_group, scales = \"free_y\") +\n  xlab(\"Chunk size (MB)\") +\n  theme( \n    legend.position = \"none\",\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    ) + \n  ggtitle('Distribution of \"runs of identical sequence\" for pairwise combination of MEMA parents using ~20K markers')\n\n\n\n\nIn general the maximum size of the “same genotype” chunks seems to be 8-16 MB depending on the pairwise cross that is being analyzed. We expect to see a reduction in the size by using WGS (higher marker density)\n\nwgs_mema_parquet_source <- \n  \"C:/Users/sergi/Documents/SAWERS LAB/MAGIC/mosaic_estimates/gen_mosaic_estimates/parents_WGS_hap.parquet\"\n\ncolnames_WGS_data <- \n  arrow::open_dataset(sources = wgs_mema_parquet_source)$schema$names\n\nWGS_parents_raw <-\n  colnames_WGS_data[-c(1:11)] %>%\n  crossing(p1 =., p2 = .) %>%\n  filter(p1 != p2) %>%\n  mutate(code = map2_chr(\n    .x = p1,\n    .y = p2,\n    .f = ~ paste0(.x, .y) %>% str_split(\"\") %>% unlist() %>% sort() %>% paste(collapse = \"\")\n    )) %>%\n  group_by(code) %>%\n  filter(row_number() == 1) %>%\n  ungroup() %>%\n  select(-code) %>%\n  mutate(\n    cols = map2(\n      .x = p1,\n      .y = p2,\n      .f = ~ c(colnames_WGS_data[c(1, 3, 4)], .x, .y)\n    )) %>%\n  mutate(comp_group_label = paste0(p1, \"_\", p2))\n\n\ndownsize_scheme <- tibble(\n  n_marker = c(5000, 10000, 20000, 50000, 100000, 500000, 1e6, 3e6, 5e6, 8125930),\n  code = c(\"5k\", \"10k\", \"20k\", \"50K\", \"100K\", \"500K\", \"1M\", \"3M\", \"5M\", \"8.2M\")\n  ) %>%\n  mutate(prop = n_marker/8125930) \n\n# for (j in 10) {\n#   \n#   for (i in 1:dim(WGS_parents_raw)[1]) {\n#     \n#     wgs_data_pre <- read_parquet(file = \"parents_WGS_hap.parquet\", col_select = all_of(WGS_parents_raw$cols[[i]])) %>%\n#       rename_with(~c(\"marker\", \"chrom\", \"pos\", \"geno1\", \"geno2\"))\n#     \n#     if (j == dim(downsize_scheme)[1]) {\n#       \n#       wgs_magic_chunks_data_pre <- wgs_data_pre\n#       \n#     } else {\n#         \n#       set.seed(100)\n#       wgs_data_split <- initial_split(wgs_data_pre, prop = downsize_scheme$prop[j], strata = chrom)\n#       wgs_magic_chunks_data_pre <- training(wgs_data_split)\n#       \n#     }\n#     \n#     wgs_magic_chunks <- \n#       wgs_magic_chunks_data_pre %>%\n#       group_by(chrom)  %>%\n#       rowid_to_column() %>%\n#       filter(geno1 == geno2) %>%\n#       mutate(\n#         dif_inicio = lead(rowid) - rowid,\n#         dif_final =  lag(dif_inicio)\n#         ) %>%\n#       filter(dif_inicio == 1 | dif_final == 1) %>%\n#       mutate(block = ifelse(dif_inicio == 1, NA, rowid)) %>%\n#       fill(block, .direction = \"up\") %>%\n#       group_by(block) %>%\n#       mutate(chunck_n_marker = n()) %>%\n#       filter(rowid == min(rowid) | rowid == max(rowid)) %>%\n#       group_by(chrom, block) %>%\n#       summarise(\n#         chunck_n_marker = first(chunck_n_marker),\n#         chunk_size = diff(pos),\n#         chunck_name = paste(first(rowid), last(rowid), sep = \"-\"),\n#         spans = paste(round(first(pos)/1e6, 2), round(last(pos)/1e6, 2), sep =\"-\")\n#         ) %>%\n#       ungroup() %>%\n#     mutate(chunk_size = round(chunk_size/1e6, 2)) %>%\n#     filter(chunk_size > 0) \n#   \n#   SINK <- paste0(WGS_parents_raw$comp_group_label[i], \"_\", downsize_scheme$code[j], \"_chunk_info.parquet\")\n#   \n#   write_parquet(wgs_magic_chunks, sink = SINK)\n#   \n#   rm(wgs_data_pre, wgs_data_split, wgs_magic_chunks_data_pre, wgs_magic_chunks, SINK)\n#   gc()\n#   \n#   }\n# }\n\nparents_mema_gws_all_data <-\n  WGS_parents_raw %>%\n  select(comp_group_label) %>%\n  mutate(ds = list(downsize_scheme)) %>%\n  unnest(ds) %>%\n  mutate(file = paste0(\n    \"C:/Users/sergi/Documents/SAWERS LAB/MAGIC/mosaic_estimates/gen_mosaic_estimates/\",\n    comp_group_label, \n    \"_\", code,\n    \"_chunk_info.parquet\")) %>%\n  mutate(data = map(\n    .x = file,\n    .f = ~ read_parquet(.x)\n  ))\n\nWGS_parents_chunk_sizes <- \n  parents_mema_gws_all_data %>%\n  unnest(data) %>%\n  group_by(comp_group_label, n_marker) %>%\n  summarise(\n    min_chunk_size = min(chunk_size),\n    med_chunk_size = median(chunk_size),\n    max_chunk_size = max(chunk_size),\n    code = first(code)\n    )\n\n`summarise()` has grouped output by 'comp_group_label'. You can override using\nthe `.groups` argument.\n\nWGS_parents_chunk_sizes %>% \n  group_by(n_marker, code) %>%\n  pivot_longer(contains(\"chunk_size\")) %>%\n  ungroup() %>%\n  filter(name != \"min_chunk_size\") %>%\n  group_by(code, name) %>%\n  filter(value == min(value) | value == max(value)) %>%\n  ungroup() %>%\n  select(-comp_group_label) %>%\n  distinct() %>%\n  arrange(n_marker, name) %>%\n  group_by(n_marker, code, name) %>%\n  summarise(interval = paste(value, collapse = \" - \")) %>%\n  pivot_wider(names_from = name, values_from = interval)\n\n`summarise()` has grouped output by 'n_marker', 'code'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 10 × 4\n# Groups:   n_marker, code [10]\n   n_marker code  max_chunk_size med_chunk_size\n      <dbl> <chr> <chr>          <chr>         \n 1     5000 5k    28.76 - 66.82  0.93 - 2.02   \n 2    10000 10k   21.82 - 56.12  0.51 - 1.01   \n 3    20000 20k   10.53 - 41.29  0.26 - 0.55   \n 4    50000 50K   7.57 - 22.21   0.13 - 0.23   \n 5   100000 100K  5.35 - 19.09   0.08 - 0.13   \n 6   500000 500K  2.46 - 7.87    0.03 - 0.05   \n 7  1000000 1M    2.38 - 5.83    0.03          \n 8  3000000 3M    5.49 - 1.19    0.02          \n 9  5000000 5M    5.33 - 1       0.02          \n10  8125930 8.2M  0.56 - 4.13    0.01 - 0.02   \n\nWGS_parents_med_chunk_sizes_plot <- \n  WGS_parents_chunk_sizes %>%\n  mutate(\n    code = as_factor(code)) %>% \n  ggplot(\n    data =., \n    aes(x = n_marker, y = med_chunk_size, color = comp_group_label, group = comp_group_label)\n  ) +\n  geom_line(linewidth = 0.75) +\n  scale_x_continuous(\n    breaks = unique(WGS_parents_chunk_sizes$n_marker),\n    labels = unique(WGS_parents_chunk_sizes$code)\n  ) +\n  xlab(\"Number of markers\") +\n  ylab(\"Median chunk size (MB)\") +\n  ggtitle('Reduction in \"same genotype chunk\" size when marker density is increased') +\n  theme(\n    panel.background = element_rect(fill = \"white\", colour = \"grey50\"),  \n    text = element_text(size = 12),\n    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 0),\n    legend.title = element_blank(),\n    plot.title = element_text(hjust = 0.5)\n    ) \n\nWGS_parents_med_chunk_sizes_plot\n\n\n\nWGS_parents_med_chunk_sizes_plot +\n  scale_x_log10(\n    breaks = unique(WGS_parents_chunk_sizes$n_marker),\n    labels = unique(WGS_parents_chunk_sizes$code)\n  ) \n\nScale for x is already present.\nAdding another scale for x, which will replace the existing scale.\n\n\n\n\nWGS_parents_max_chunk_sizes_plot <-\n  WGS_parents_chunk_sizes %>%\n  mutate(\n    code = as_factor(code)) %>% \n  ggplot(\n    data =., \n    aes(x = n_marker, y = max_chunk_size, color = comp_group_label, group = comp_group_label)\n  ) +\n  geom_line(linewidth = 0.75) +\n  scale_x_continuous(\n    breaks = unique(WGS_parents_chunk_sizes$n_marker),\n    labels = unique(WGS_parents_chunk_sizes$code)\n  ) +\n  xlab(\"Number of markers\") +\n  ylab(\"Maximum chunk size (MB)\") +\n  ggtitle('Reduction in \"same genotype chunk\" size when marker density is increased') +\n  theme(\n    panel.background = element_rect(fill = \"white\", colour = \"grey50\"),  \n    text = element_text(size = 12),\n    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 0),\n    legend.title = element_blank(),\n    plot.title = element_text(hjust = 0.5)\n    ) \n\nWGS_parents_max_chunk_sizes_plot\n\n\n\nWGS_parents_max_chunk_sizes_plot +\n  scale_x_log10(\n    breaks = unique(WGS_parents_chunk_sizes$n_marker),\n    labels = unique(WGS_parents_chunk_sizes$code)\n  ) \n\nScale for x is already present.\nAdding another scale for x, which will replace the existing scale.\n\n\n\n\ndif_chunk_size_par <- \n  WGS_parents_chunk_sizes %>%\n  group_by(comp_group_label) %>%\n  mutate(\n    dif_med = med_chunk_size - lead(med_chunk_size),\n    dif_max = max_chunk_size - lead(max_chunk_size),\n    code2 = lead(code),\n    code2 = paste0(code, \"-\", code2)\n    ) %>%\n  filter(!is.na(dif_med)) %>%\n  mutate(code2 = as_factor(code2)) \n\ndif_chunk_size_par %>%\n  ggplot(\n    data =., \n    aes(x = code2, y = dif_med, color = comp_group_label, group = comp_group_label)) +\n  geom_line()  +\n  xlab(NULL) +\n  ylab(\"Median chunk size (MB)\") +\n  ggtitle('Difference in the median chunk size as the number of markers is increased') +\n  theme(\n    panel.background = element_rect(fill = \"white\", colour = \"grey50\"),  \n    text = element_text(size = 12),\n    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 0),\n    legend.title = element_blank(),\n    plot.title = element_text(hjust = 0.5)\n    ) \n\n\n\ndif_chunk_size_par %>%\n  ggplot(\n    data =., \n    aes(x = code2, y = dif_max, color = comp_group_label, group = comp_group_label)) +\n  geom_line()  +\n  xlab(NULL) +\n  ylab(\"Median chunk size (MB)\") +\n  ggtitle('Difference in the maximum chunk size as the number of markers is increased') +\n  theme(\n    panel.background = element_rect(fill = \"white\", colour = \"grey50\"),  \n    text = element_text(size = 12),\n    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 0),\n    legend.title = element_blank(),\n    plot.title = element_text(hjust = 0.5)\n    ) \n\n\n\n\nWe hypothesize that the big amount of missing information in the assignment of a parental haplotypes for markers in the MEMA population is because at the actual marker density (~ 15K markers) rqtl2 cannot differentiate between any parent with a 95% of confidence, thus generating missing information. This leads us to think that is because there are genomic regions in the parents that have “identical genotype (IBD?)”, making difficult or impossible for qtl2 to differentiate one parent from the other. So we think that if we can reduce the size of this “same genotype” regions by identifying polymorphic markers across each pair of parents, we can give more information to rqtl2 to assign a parental haplotype and reduce the number of misscalling.\nThe question here is: how big are this regions? and If we increase the genome-wide marker density, can we reduce the size of this regions? Can we add more information with more markers? How many markers do we need to add more information and reduce the size of the “same genotype chunks”?\nTo answer these questions we assess the size of the “same genotype” regions in each pairwise combination of the parents of the MEMA population by using the 50K CHIP marker data (~ 15K SNPs) and WGS data (~8.2M SNPs). We use a “down-scale” simulation with the WGS data, where we randomly sampled markers across the genome with the same proportion of markers per chromosome as the original dataset, to assess if we can observe a gradient of how much information we acquire (in terms of reduction of the size of the same genotype chunks) as we increase the marker density. We selected 5000, 10,000, 20,000, 100,000, 1,000,000, 3,000,000, 5,000,000 and 8,200,000 markers to answer this question.\nFor the CHIP dataset, the same chunk genotype median and max size can go from 0.17-0.24 MB and 5.09-19 MB respectively. For WGS data, we can observe that an increase of the number of markers leads to the reduction of the median and max same genotype chunk size, for instance, with 50,000 markers we get a median chunk size from 0.13 - 0.23 MB and max size of 7.57 - 22.21 MB, and as we increase the marker density we observe a reduction in these values. So we can conclude that more dense marker data increases the information on the parents of the MEMA population. So it is worth to find a genotyping way that can increase the density of markers, like skim sequencing + imputation."
  },
  {
    "objectID": "CML.html",
    "href": "CML.html",
    "title": "CML",
    "section": "",
    "text": "Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "CML.html#running-code",
    "href": "CML.html#running-code",
    "title": "CML",
    "section": "Running Code",
    "text": "Running Code\nWhen you click the Render button a document will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n1 + 1\n\n[1] 2\n\n\nYou can add options to executable code like this\n\n\n[1] 4\n\n\nThe echo: false option disables the printing of code (only output is displayed)."
  },
  {
    "objectID": "CML-2023-03-12-23_Highland_Ameca_Experimental_Design.html",
    "href": "CML-2023-03-12-23_Highland_Ameca_Experimental_Design.html",
    "title": "3  2023_Highland_experiment_design",
    "section": "",
    "text": "There is an augmented block design for Ameca, a possible “no stress” environment where we can have a baseline to compare the performance of the highland site. Here, the experiment is composed of a 53 block per repetition, and 2 replications, with the same genotypes as the p-rep design. Each genotype is present only once per replication and is not repeated across block either.\nLoading libraries\n\nlibrary(FielDHub)\nlibrary(googlesheets4)\n\nWarning: package 'googlesheets4' was built under R version 4.2.2\n\nlibrary(googledrive)\n\n\nAttaching package: 'googledrive'\n\n\nThe following objects are masked from 'package:googlesheets4':\n\n    request_generate, request_make\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2\n──\n\n\n✔ ggplot2 3.4.1      ✔ purrr   1.0.1 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.3.0      ✔ stringr 1.5.0 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n\n\nWarning: package 'ggplot2' was built under R version 4.2.2\n\n\nWarning: package 'tidyr' was built under R version 4.2.2\n\n\nWarning: package 'readr' was built under R version 4.2.2\n\n\nWarning: package 'purrr' was built under R version 4.2.2\n\n\nWarning: package 'dplyr' was built under R version 4.2.2\n\n\nWarning: package 'stringr' was built under R version 4.2.2\n\n\nWarning: package 'forcats' was built under R version 4.2.2\n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter()                 masks stats::filter()\n✖ dplyr::lag()                    masks stats::lag()\n✖ googledrive::request_generate() masks googlesheets4::request_generate()\n✖ googledrive::request_make()     masks googlesheets4::request_make()\n\nlibrary(lme4)\n\nWarning: package 'lme4' was built under R version 4.2.2\n\n\nLoading required package: Matrix\n\n\nWarning: package 'Matrix' was built under R version 4.2.2\n\n\n\nAttaching package: 'Matrix'\n\nThe following objects are masked from 'package:tidyr':\n\n    expand, pack, unpack\n\ngs4_auth(\"checo.spl@gmail.com\")\n\nImport available genotypes and genotype information\n\n# raw data for genotypes\ndata_url <- \"https://docs.google.com/spreadsheets/d/14yHP2kqQZQ-wp0IdiUgeUeQIeqorQed3-m-xcwFu_Ko/edit#gid=723581705\"\n\ngenotypes_data_raw <- \n  data_url %>%\n  as_id() %>%\n  range_read(sheet = \"Genetic Stocks\")\n\nAuto-refreshing stale OAuth token.\n\n\n✖ Request failed [429]. Retry 1 happens in 1.6 seconds ...\n\n\n✔ Reading from \"CML457_459_Populations\".\n\n\n✔ Range ''Genetic Stocks''.\n\nfamilies_url <- \"https://docs.google.com/spreadsheets/d/1Mix1vFbJkeLhC3psHaOxxJscgPXsiizt-unjrE1Arbs/edit#gid=497667827\"\n\nseed_availability_url <- \"https://docs.google.com/spreadsheets/d/14yHP2kqQZQ-wp0IdiUgeUeQIeqorQed3-m-xcwFu_Ko/edit#gid=723581705\"\n\n# Import raw data for families\nfamilies_data_raw <- families_url %>%\n  as_id %>%\n  range_read(ss =., sheet = \"UNISEM21A\", skip = 1)\n\n✖ Request failed [429]. Retry 1 happens in 2.5 seconds ...\n\n\n✔ Reading from \"21_NCS_PSU_LANGEBIO_FIELDS\".\n\n\n✔ Range ''UNISEM21A'!2:10000000'.\n\n\nNew names:\n• `` -> `...16`\n• `` -> `...18`\n\nseed_available <- seed_availability_url %>%\n  as_id() %>%\n  range_read(ss =., sheet = \"Genetic Stocks\")\n\n✔ Reading from \"CML457_459_Populations\".\n✔ Range ''Genetic Stocks''.\n\npacking_seed_info_url <- \"https://docs.google.com/spreadsheets/d/14yHP2kqQZQ-wp0IdiUgeUeQIeqorQed3-m-xcwFu_Ko/edit#gid=2014961217\"\n\n# packing seed info\n\npacking_seed_info <- \n  packing_seed_info_url %>%\n  as_id() %>%\n  range_read(ss =., sheet = \"seed_packing_2022\")\n\n✔ Reading from \"CML457_459_Populations\".\n✔ Range ''seed_packing_2022''.\n\npacking_seed_info_unique <- \n  packing_seed_info %>%\n  select(familia, F2_Parent, sobre_UNISEM) %>%\n  unique() %>%\n  rename(`Female genotype` = familia, `Female parent` = sobre_UNISEM)\n\nHighland site p-rep design\n\n# Genotypes available for planting\n\navailable_genos <- \n  genotypes_data_raw %>%\n  select(family = Family_ID, pop = Population_ID, use = `Use_23 (798)`) %>%\n  filter(use == 1)\n\n# select families based on the best BLUP values\ncml_pops_raw_data <- \n  data_url %>%\n  as_id() %>%\n  range_read(\"22_Highland_Raw_data_tidy\") %>%\n  mutate(phc = as.double(phc)) \n\n✖ Request failed [429]. Retry 1 happens in 1.6 seconds ...\n\n\n✖ Request failed [429]. Retry 2 happens in 10.6 seconds ...\n\n\n✔ Reading from \"CML457_459_Populations\".\n\n\n✔ Range ''22_Highland_Raw_data_tidy''.\n\n\n✖ Request failed [429]. Retry 1 happens in 1.6 seconds ...\n\n\n✖ Request failed [429]. Retry 2 happens in 4.5 seconds ...\n\n\n✖ Request failed [429]. Retry 3 happens in 16.8 seconds ...\n\ncml_phc_example <-\n  cml_pops_raw_data %>%\n  select(location, family, phc, nblock) %>%\n  mutate(across(c(location, family), ~ as_factor(.))) %>%\n  mutate(phc = ifelse(phc > 2 | phc == 0, NA_real_, phc)) %>%\n  filter(family != \"HERMES\")\n\nset.seed(100)\nphc_BLUP_example <- \n  lmer(\n    phc ~ location + (1|family) + (1|location:nblock), data = cml_phc_example\n    ) %>%\n  ranef() %>%\n  .$family %>%\n  as_tibble(rownames = \"family\") %>%\n  rename(BLUP = `(Intercept)`)\n\n# Best families available based on the BLUP value\nprospect_families <- \n  phc_BLUP_example %>%\n  semi_join(available_genos) %>%\n  mutate(pop = gsub(\"-\\\\d+$\", \"\", family)) %>%\n  arrange(pop, desc(BLUP)) %>%\n  group_by(pop) %>%\n  mutate(id = row_number()) %>%\n  filter(\n    (pop == \"HI73\" & id %in% c(1:210)) | \n      (pop == \"HI93\" & id %in% c(1:210)) |\n      (pop == \"HI79\" & id %in% c(1:320))\n  ) %>%\n  ungroup() %>%\n  rename(phc_BLUP = BLUP)\n\nJoining, by = \"family\"\n\n# p-rep eperimental design using FieldHub\n\nhighland_2023_prep_design <- \n  partially_replicated(\n    nrows = 40, \n    ncols = 25,\n    repGens = c(530, 210, 1),\n    repUnits = c(1, 2, 50),\n    planter = \"serpentine\",\n    l = 2,\n    seed = 100,\n    locationNames = c(\"site1\", \"site2\")\n    )\n\nWarning message: \n Since plotNumber was missing, it was set up to default value of:  1001 2001 \n \n\n\n\n\n# Extracting the fieldbook from the experimental design\nhigh23_fieldbook <- \n  highland_2023_prep_design$fieldBook %>%\n  as_tibble() %>%\n  rename_with(~tolower(.))\n\n# Selecting rep families by random and randomizing families within each pop\nset.seed(100)\nhigh_exp_data <-\n  prospect_families %>%\n  group_by(pop) %>%\n  slice_sample(prop = 1) %>%\n  mutate(id2 = row_number()) %>%\n  ungroup() %>%\n  select(family, pop, id2) %>%\n  add_row(family = \"CHECK\", id2 = NA, .before = 1) %>%\n  mutate(\n    rep = case_when(\n      is.na(id2) ~ 50,\n      id2 %in% c(1:70) ~ 2,\n      T ~ 1\n    )) %>%\n  arrange(desc(rep), pop, id2) %>%\n  mutate(id = row_number())\n\ntreatment_family <- \n  high23_fieldbook %>%\n  count(location, treatment) %>%\n  mutate(id = gsub(\"G\", \"\", treatment) %>% as.integer()) %>%\n  rename(rep = n) %>%\n  arrange(id) %>%\n  left_join(high_exp_data) %>%\n  select(treatment, family, pop) %>%\n  distinct() %>%\n  mutate(pop = ifelse(is.na(pop), \"CHECK\", pop))\n\nJoining, by = c(\"rep\", \"id\")\n\nhigh23_fieldbook_family <- \n  high23_fieldbook %>%\n  left_join(treatment_family) \n\nJoining, by = \"treatment\"\n\nhigh23_fieldbook_family\n\n# A tibble: 2,000 × 12\n      id expt  location year   plot   row column checks entry treatment family  \n   <int> <chr> <chr>    <chr> <dbl> <int>  <int> <chr>  <dbl> <chr>     <chr>   \n 1     1 Expt1 SITE1    2023   1001     1      1 186      186 G186      HI93-271\n 2     2 Expt1 SITE1    2023   1002     1      2 0        574 G574      HI79-370\n 3     3 Expt1 SITE1    2023   1003     1      3 0        218 G218      HI73-028\n 4     4 Expt1 SITE1    2023   1004     1      4 0        508 G508      HI79-280\n 5     5 Expt1 SITE1    2023   1005     1      5 0        567 G567      HI79-306\n 6     6 Expt1 SITE1    2023   1006     1      6 115      115 G115      HI79-286\n 7     7 Expt1 SITE1    2023   1007     1      7 0        444 G444      HI79-321\n 8     8 Expt1 SITE1    2023   1008     1      8 0        384 G384      HI79-191\n 9     9 Expt1 SITE1    2023   1009     1      9 1          1 G1        CHECK   \n10    10 Expt1 SITE1    2023   1010     1     10 0        482 G482      HI79-104\n# … with 1,990 more rows, and 1 more variable: pop <chr>\n\nhigh23_fieldbook_family %>%\n  ggplot(data =., aes(x = row, y = column)) +\n  geom_tile(\n    aes(fill = pop),\n    color = \"black\") +\n  facet_grid(. ~ location)\n\n\n\ndata_spreadsheet <-\n  high23_fieldbook_family %>%\n  select(\n    `CML23-` = plot, Description = pop, `Female genotype` = family, \n    row_design = row, column_design = column, checks) %>%\n  mutate(\n    `Origin (Package)` = \"LANGEBIO\",\n    `Packed?` = \" \",\n    `Who/What` = \"AL/JL\",\n    `Male parent` = \"x sib\",\n    `Male genotype` = \"x sib\",\n    `Number/Selection` = \"14K\",\n    rep = case_when(\n      checks == 0 ~ 1,\n      Description == \"CHECK\" ~ 50,\n      T ~ 2\n    )\n  ) %>%\n  left_join(packing_seed_info_unique) %>%\n  select(\n    `CML23-`, `Origin (Package)`:`Who/What`, Description, `Female parent`, \n    `Male parent`, `Female genotype`,  `Male genotype`, `Number/Selection`,\n    row_design, column_design, rep\n    ) %>%\n  mutate(across(contains(\"Female\"), ~ ifelse(is.na(.), \"HERMES\", .)))\n\nJoining, by = \"Female genotype\"\n\nwrite_csv(data_spreadsheet, \"23_highland_experiment_spreadsheet.csv\")\n\nAmeca augmented complete block design\n\nprospect_families %>%\n  count(pop) %>%\n  mutate(prop = n/sum(n)) %>%\n  mutate(a = prop*24)\n\n# A tibble: 3 × 4\n  pop       n  prop     a\n  <chr> <int> <dbl> <dbl>\n1 HI73    210 0.284  6.81\n2 HI79    320 0.432 10.4 \n3 HI93    210 0.284  6.81\n\nprospect_families %>% dim %>% .[[1]]\n\n[1] 740\n\nAmeca_RCBD <- RCBD_augmented(\n  lines = prospect_families %>% dim %>% .[[1]],\n  planter = \"serpentine\",\n  checks = 1,\n  b = 53, \n  repsExpt = 2, \n  l = 1,\n  random = TRUE,\n  locationNames = c(\"Ameca\"),\n  seed = 100, \n  )\n\n# 57, 53, 50, 47, 44\n\nAmeca_fieldbook <- Ameca_RCBD$fieldBook %>%\n  as_tibble() %>%\n  rename_with( ~ tolower(.))\n\nAmeca_fieldbook %>%\n  filter(treatment != \"CH1\") %>%\n  count(block) %>%\n  mutate(nn = n/2) %>%\n  count(nn)\n\n# A tibble: 1 × 2\n     nn     n\n  <dbl> <int>\n1    14    53\n\nprospect_families %>%\n  count(pop) %>% \n  mutate(prop = n/sum(n)) %>%\n  mutate(a = prop*14)\n\n# A tibble: 3 × 4\n  pop       n  prop     a\n  <chr> <int> <dbl> <dbl>\n1 HI73    210 0.284  3.97\n2 HI79    320 0.432  6.05\n3 HI93    210 0.284  3.97\n\n# Per block: 4 HI73/HI93; 6 HI79\n\nset.seed(100)\nAmeca_fieldbook_pops <- \n  Ameca_fieldbook %>%\n  mutate(rep = ifelse(id < 796, 1, 2)) %>%\n  group_by(rep, block) %>%\n  mutate(rowid = row_number()) %>%\n  slice_sample(prop = 1) %>%\n  mutate(\n    type = ifelse(treatment == \"CH1\", \"check\", \"family\"),\n    type = factor(type, levels = c(\"check\", \"family\"))\n    ) %>%\n  ungroup() %>%\n  arrange(rep, block, type) %>%\n  mutate(what = rep(c(\"HERMES\", rep(\"HI73\", 4), rep(\"HI79\", 6), rep(\"HI93\", 4)), 106)) %>%\n  filter(treatment != \"Filler\")\n\nAmeca_fieldbook_pops %>%\n  count(rep, what)\n\n# A tibble: 8 × 3\n    rep what       n\n  <dbl> <chr>  <int>\n1     1 HERMES    53\n2     1 HI73     211\n3     1 HI79     317\n4     1 HI93     212\n5     2 HERMES    53\n6     2 HI73     211\n7     2 HI79     318\n8     2 HI93     211\n\n# Need 420 HI73/HI93; 640 HI79\n\nset.seed(100)\nextra_family_replacement <- \n  Ameca_fieldbook_pops %>%\n  filter(what %in% c(\"HI93\", \"HI73\")) %>%\n  group_by(rep, what) %>%\n  slice_sample(n = 3) %>%\n  filter(\n    (rep == 1 & what == \"HI73\" & row_number() == 1) |\n      (rep == 1 & what == \"HI93\" & row_number() %in% c(1:2)) |\n      (rep == 2 & what == \"HI73\" & row_number() %in% c(1)) |\n      (rep == 2 & what == \"HI93\" & row_number() %in% c(1))\n  ) %>%\n  mutate(what = \"HI79\")\n\n\nset.seed(100)\nAmeca_fieldbook_pops_family <- Ameca_fieldbook_pops %>%\n  anti_join(extra_family_replacement, by = c(\"rep\", \"plot\")) %>%\n  bind_rows(extra_family_replacement) %>%\n  arrange(rep, what) %>%\n  group_by(rep, what) %>%\n  slice_sample(prop = 1) %>%\n  mutate(id2 = row_number()) %>%\n  left_join(prospect_families %>% select(-phc_BLUP), by = c(\"what\" = \"pop\", \"id2\" = \"id\")) %>%\n  mutate(family = ifelse(what == \"HERMES\", \"HERMES\", family)) %>%\n  ungroup()\n\nAmeca_fieldbook_pops_family %>%\n  arrange(id) %>%\n  select(id, plot:block, rep, treatment, pop = what, family)\n\n# A tibble: 1,586 × 10\n      id  plot   row column checks block   rep treatment pop    family  \n   <int> <dbl> <int>  <int> <chr>  <dbl> <dbl> <chr>     <chr>  <chr>   \n 1     1   101     1      1 0          1     1 G658      HI93   HI93-179\n 2     2   102     1      2 1          1     1 CH1       HERMES HERMES  \n 3     3   103     1      3 0          1     1 G205      HI73   HI73-092\n 4     4   104     1      4 0          1     1 G133      HI93   HI93-233\n 5     5   105     1      5 0          1     1 G641      HI93   HI93-108\n 6     6   106     1      6 0          1     1 G321      HI73   HI73-137\n 7     7   107     1      7 0          1     1 G418      HI73   HI73-220\n 8     8   108     1      8 0          1     1 G44       HI79   HI79-162\n 9     9   109     1      9 0          1     1 G636      HI79   HI79-268\n10    10   110     1     10 0          1     1 G391      HI73   HI73-248\n# … with 1,576 more rows\n\nAmeca_fieldbook_pops_family %>%\n  select(id, plot:block, rep, treatment, pop = what, family) %>%\n  ggplot(data =., aes(x = column, y = row, fill = pop)) +\n  geom_tile(color = \"black\")\n\n\n\nAmeca_data_spreadsheet <-\n  Ameca_fieldbook_pops_family %>%\n  arrange(id) %>%\n  mutate(`CML23-` = id + 4000) %>%\n  select(\n    `CML23-`, Description = what, `Female genotype` = family, \n    row_design = row, column_design = column, checks, rep, block) %>%\n  mutate(\n    `Origin (Package)` = \"LANGEBIO\",\n    `Packed?` = \" \",\n    `Who/What` = \"AL/JL\",\n    `Male parent` = \"x sib\",\n    `Male genotype` = \"x sib\",\n    `Number/Selection` = \"14K\"\n    ) %>%\n  left_join(packing_seed_info_unique) %>%\n  select(\n    `CML23-`, `Origin (Package)`:`Who/What`, Description, `Female parent`, \n    `Male parent`, `Female genotype`,  `Male genotype`, `Number/Selection`,\n    row_design, column_design, rep, block\n    ) %>%\n  mutate(across(contains(\"Female\"), ~ ifelse(is.na(.), \"HERMES\", .)))\n\nJoining, by = \"Female genotype\"\n\nwrite_csv(Ameca_data_spreadsheet, \"Ameca_data_spreadsheet.csv\")"
  },
  {
    "objectID": "PT.html",
    "href": "PT.html",
    "title": "4  PT",
    "section": "",
    "text": "Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "PT.html#running-code",
    "href": "PT.html#running-code",
    "title": "4  PT",
    "section": "4.2 Running Code",
    "text": "4.2 Running Code\nWhen you click the Render button a document will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n1 + 1\n\n[1] 2\n\n\nYou can add options to executable code like this\n\n\n[1] 4\n\n\nThe echo: false option disables the printing of code (only output is displayed)."
  },
  {
    "objectID": "AMF.html",
    "href": "AMF.html",
    "title": "5  AMF",
    "section": "",
    "text": "Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "AMF.html#running-code",
    "href": "AMF.html#running-code",
    "title": "5  AMF",
    "section": "5.2 Running Code",
    "text": "5.2 Running Code\nWhen you click the Render button a document will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n1 + 1\n\n[1] 2\n\n\nYou can add options to executable code like this\n\n\n[1] 4\n\n\nThe echo: false option disables the printing of code (only output is displayed)."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "6  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  }
]